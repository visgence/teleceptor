#!/usr/bin/env python
"""
(c) 2014 Visgence, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
"""



import runpy
import sys, os, glob, atexit
import argparse
import shutil
import platform
from sqlalchemy import create_engine
import teleceptor
from  teleceptor import models
from  teleceptor import testFixtures
from teleceptor import server

Stdin = '/dev/null'
Stdout = '/dev/null'
Stderr = '/dev/null'

def delpid():
    os.remove(self.pidfile)
def runserver(*args):
    """
    do the UNIX double-fork magic, see Stevens' "Advanced
    Programming in the UNIX Environment" for details (ISBN 0201563177)
    http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
    """        
    server.runserver(server.get_cp_config())

def btcmote(*args):
    btcmotecmd = os.path.join(teleceptor.__path__[0],'softSensors','BitcoinSensor','BTCMote.py')
    print btcmotecmd
    runpy.run_path(btcmotecmd,None,'__main__')

def poller(*args):
    pollercmd = os.path.join(teleceptor.__path__[0],'basestation','poller.py')
    print pollercmd
    runpy.run_path(pollercmd,None,'__main__')

def tcpPoller(*args):
    tcppollercmd = os.path.join(teleceptor.__path__[0],'basestation','tcpPoller.py')
    print tcppollercmd
    runpy.run_path(tcppollercmd,None,'__main__')

def copyConfig(*args):
    if platform.system() == 'Windows':
        appdata = os.path.join(os.getenv("APPDATA"),"teleceptor")
    else:
        appdata = os.path.join(os.getenv("HOME"),".config","teleceptor")
    
    #Check if file exists
    if os.path.exists(os.path.join(appdata,'config.json')):
        print "Config Exists at: " + str(os.path.join(appdata,'config.json'))
        return
    
    if not os.path.exists(appdata):
        os.makedirs(appdata)
    
    fromfile = os.path.join(teleceptor.PATH,'config',"defaults.json")
    tofile = os.path.join(appdata,"config.json")
    shutil.copy2(fromfile,tofile)
    
    print "Config installed at:" + str(tofile)
    

def displayVersion(*args):
    print "teleceptor Version: " + teleceptor.__version__

def rebuild(*args):

    print 'This command will wipe your database and start fresh.  Are you sure you want to continue?'
    user_resp = None
    user_resp = raw_input('(Y/n) ').rstrip()
    while user_resp not in ['Y', 'n']:
        print 'Did not understand your response.  Please enter \'Y\' or \'n\'.'
        print 'This command will wipe your database and start fresh.  Are you sure you want to continue?'
        user_resp = raw_input('(Y/n) ').rstrip()

    if user_resp == 'n':
        sys.exit(0)

    assert user_resp == 'Y', 'Something Bad Happened!'

    print "Deleting base_station.db..."
    try:
        os.remove(teleceptor.DBFILE)
        print teleceptor.DBFILE + " deleted."
    except OSError:
        print('base_station.db does not exist.  Creating new db.')
        
    print "Deleting whisper files"
    for g in glob.glob(os.path.join(teleceptor.WHISPER_DATA,"*.wsp")):
        try:
            os.remove(g)
            print g + " deleted."
        except:
            print "Could not delete " + g
            

    print "Runing setup."
    setup()

def setup(*args):

    print "Creating new base_station.db file..."
    if not os.path.exists(os.path.dirname(teleceptor.DBFILE)):
        os.makedirs(os.path.dirname(teleceptor.DBFILE))
    open(teleceptor.DBFILE, 'a').close()
    print teleceptor.DBFILE + " created."

    db = create_engine('sqlite:///' + teleceptor.DBFILE)

    print "Initializing database tables..."
    models.Base.metadata.create_all(db)
    
    print "Run teleceptorcmd loadfixtures for example data"

def loadfixtures(*args):
    print "Loading fixtures..."
    testFixtures.main()

if __name__ == "__main__":
    cmds = {
         'runserver': [runserver,"Start the server"]
        ,'copyconfig': [copyConfig,"Copy default config to home"]
        ,'rebuild': [rebuild,"Rebuild the database and datafiles"]
        ,'setup': [setup,"Build the database"]
        ,'btcmote': [btcmote,"Example sensor that collects BTC informaiotn"]
        ,'poller': [poller,"Serial poller"]
        ,'tcppoller': [tcpPoller,"TCP poller (Hosts are added in config.json)"]
        ,'loadfixtures': [loadfixtures,"Load test database data"]
        ,'version': [displayVersion,"Display version"]
    }



    args = sys.argv
    if len(args) > 1 and args[1].lower() in cmds:
        
        if len(args) > 2 and args[2] == "-d":
            print "Starting process %s as daemon..." % args[1].lower()
            pidfilename = "/tmp/teleceptor-" + args[1].lower() + '.pid'
            try:
                pid = os.fork()
                if pid > 0:
                    # exit first parent
                    sys.exit(0)
            except OSError, e:
                sys.stderr.write("fork #1 failed: %d (%s)\n" % (e.errno, e.strerror))
                sys.exit(1)

            # decouple from parent environment
            os.chdir("/")
            os.setsid()
            os.umask(0)

            # do second fork
            try:
                pid = os.fork()
                if pid > 0:
                    # exit from second parent
                    sys.exit(0)
            except OSError, e:
                sys.stderr.write("fork #2 failed: %d (%s)\n" % (e.errno, e.strerror))
                sys.exit(1)

            print "pid: %s" % os.getpid()
            # redirect standard file descriptors
            
            sys.stdout.flush()
            sys.stderr.flush()
            si = file(Stdin, 'r')
            so = file(Stdout, 'a+')
            se = file(Stderr, 'a+', 0)
            os.dup2(si.fileno(), sys.stdin.fileno())
            os.dup2(so.fileno(), sys.stdout.fileno())
            os.dup2(se.fileno(), sys.stderr.fileno())
            

            # write pidfile
            atexit.register(delpid)
            pid = str(os.getpid())
            file(pidfilename,'w+').write("%s\n" % pid)

        cmds[args[1].lower()][0](args[2:])
        print "Done!"

    else:
        print "Please enter a valid command"
        print "Commands Are:"
        for c in sorted(cmds):
            print "    %s : %s" % (c,cmds[c][1])
        
        
